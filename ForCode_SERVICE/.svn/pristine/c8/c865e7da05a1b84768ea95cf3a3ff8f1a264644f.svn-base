package br.edu.service.forcode.services;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;

import net.lingala.zip4j.core.ZipFile;
import net.lingala.zip4j.exception.ZipException;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jboss.resteasy.annotations.providers.multipart.MultipartForm;

import br.edu.commons.forcode.contests.ForCodeUploadFile;
import br.edu.commons.forcode.contests.Problem;
import br.edu.commons.forcode.contests.Submission;
import br.edu.commons.forcode.contests.TestCase;
import br.edu.commons.forcode.entities.ForCodeError;
import br.edu.commons.forcode.enumerations.FileType;
import br.edu.service.forcode.database.dao.ProblemDAO;
import br.edu.service.forcode.database.dao.SubmissionDAO;
import br.edu.service.forcode.judgeServices.JudgeService;
import br.edu.service.forcode.judgeServices.ProviderServiceFactory;
import br.edu.service.forcode.util.ErrorFactory;

@Path("upload")
public class ForCodeUploadService {
	/**
	 * Is responsible for operations involving files manipulations, especially
	 * those related to submissions and problems.
	 * 
	 * @author: rerissondaniel
	 */

	private static final Logger logger = LogManager.getLogger(ForCodeUploadService.class);

	private static final String FORCODE_FOLDER = System.getProperty("user.home") + "/ForCode";
	
	private static final String SUBMISSION_PATH = System.getProperty("user.home")
			+ "/ForCode/Contests/";
	private static final String TESTCASE_PATH = System.getProperty("user.home")
			+ "/ForCode/Problems/";
	private static final String TEMP_FOLDER = System.getProperty("user.home") 
			+ "/ForCode/.tmp";
	
	private static final int MAX_SUBMISSION_FILE_SIZE_IN_BYTES = 2097152;
	private static final int MAX_TESTCASE_FILE_SIZE_IN_BYTES = 134217728;
	
	public ForCodeUploadService() {
		File file;		
		file = new File(FORCODE_FOLDER);
		if(!file.exists())file.mkdirs();
		
		file = new File(SUBMISSION_PATH);
		if(!file.exists())file.mkdirs();
		
		file = new File(TESTCASE_PATH);
		if(!file.exists())file.mkdirs();
		
		file = new File(TEMP_FOLDER);
		if(!file.exists())file.mkdirs();
	}
	
	/**
	 * Creates a directory for the submission and requests a verdict for it from
	 * the judge service. Temporarily its necessary the JudgeService to be
	 * hosted in the same server.
	 * 
	 * @param idSubmission
	 *            The id of the submission to be judged.
	 * @param form
	 *            A form containing the byte array relative to the
	 *            submissionFile.
	 * @return A response signaling the success or not of the operation.
	 */

	@POST
	@Path("/submission/{idSubmission}")
	@Consumes("multipart/form-data; charset=UTF-8")
	public Response judgeSubmissionFile(@PathParam("idSubmission") Integer idSubmission,
			@MultipartForm ForCodeUploadFile form) {

		ResponseBuilder builder;

		if (form.getFileType().getId() != FileType.SUBMISSION_FILE.getId()) {

			logger.info("File for submission not accepted.");
			builder = Response.status(Response.Status.NOT_ACCEPTABLE);

		} else if (form.getFile().length >= MAX_SUBMISSION_FILE_SIZE_IN_BYTES) {

			logger.info("Submission file is too large.");
			ForCodeError error = ErrorFactory.getErrorFromIndex(ErrorFactory.FILE_TOO_LARGE);
			builder = Response.status(Response.Status.NOT_ACCEPTABLE).entity(error);

		} else {
			SubmissionDAO submissionDao = new SubmissionDAO();
			Submission submission = submissionDao.getById(idSubmission);

			JudgeService judgeService = ProviderServiceFactory
					.createServiceClient(JudgeService.class);

			File submissionFile = new File(SUBMISSION_PATH
					+ submission.getUser().getIdUserContest() + submission.getIdSubmission()
					+ form.getFileName() + "." + form.getFileExtension());

			try {
				FileUtils.writeByteArrayToFile(submissionFile, form.getFile());

				submission.setFileSubmission(submissionFile);
				submission.setVerdict(judgeService.judgeSubmission(submission).getTypeValue());

				submissionDao.update(submission);

				builder = Response.status(Response.Status.ACCEPTED).entity(submission);

			} catch (IOException ioException) {

				builder = Response.status(Response.Status.INTERNAL_SERVER_ERROR);
			}
		}

		return builder.build();
	}

	public static void main(String[] args) throws FileNotFoundException, IOException {
		Problem problem = new ProblemDAO().getById(1);
		ForCodeUploadFile form = new ForCodeUploadFile();
		form.setFile(IOUtils.toByteArray(new FileInputStream(new File(
				"/home/rerissondaniel/hue.zip"))));
		form.setFileType(FileType.PROBLEM_TEST_ZIP);
		System.out.println(new ForCodeUploadService().uploadTestCaseFile(form,
				problem.getIdProblem()));
	}

	@POST
	@Path("testcase/{idProblem}")
	@Consumes("multipart/form-data; charset=UTF-8")
	// public Response uploadTestCaseFile(
	// @PathParam("idProblem") Integer idProblem,
	// @MultipartForm ForCodeUploadFile form) {
	public Response uploadTestCaseFile(ForCodeUploadFile form, Integer idProblem) {

		ProblemDAO problemDao = new ProblemDAO();
		Problem problem = problemDao.getById(idProblem);

		File tempZip = new File(TEMP_FOLDER + "/temptestcase.zip");

		ResponseBuilder builder;

		if (form.getFile().length >= MAX_TESTCASE_FILE_SIZE_IN_BYTES) {

			ForCodeError error = ErrorFactory.getErrorFromIndex(ErrorFactory.FILE_TOO_LARGE);
			builder = Response.status(Response.Status.NOT_ACCEPTABLE).entity(error);

			return builder.build();
		} else {

			logger.info("Creating new temporary zip file containing testCases in"
					+ tempZip.getAbsolutePath());
			
			try {
				tempZip.createNewFile();

				FileOutputStream fos = new FileOutputStream(tempZip);
				fos.write(form.getFile());
				fos.flush();
				fos.close();
				
			} catch (IOException ioex) {
				logger.fatal("Error while trying to create new file");
				logger.fatal(ioex.getMessage());
				
				builder = Response.status(Response.Status.INTERNAL_SERVER_ERROR);
				
				return builder.build();
			}

			logger.info("Zip file created.");
			
			try {
				File finalTestCasePath;
				ZipFile zipFile = new ZipFile(tempZip);

				finalTestCasePath = new File(TESTCASE_PATH + problem.getIdProblem()
						+ "/testcases/");
				
				logger.info("Extracting Testcases into " + finalTestCasePath.getAbsolutePath());

				zipFile.extractAll(finalTestCasePath.getAbsolutePath());
				tempZip.delete();
				
				File aux;
				TestCase testCase;

				for (String file : finalTestCasePath.list()) {
					aux = new File(finalTestCasePath + "/" + file);
					System.out.println(aux.getAbsolutePath());
					if (aux.isDirectory()) {
						testCase = new TestCase();
						testCase.setPath(aux.getAbsolutePath());
						testCase.setInput(new File(aux.list()[0]));
						testCase.setOutput(new File(aux.list()[1]));
						testCase.setProblem(problem);
						
						problem.getTestcases().add(testCase);
					}
				}

				logger.info("Updating problem data");
				
				problemDao.update(problem);

				builder = Response.status(Response.Status.ACCEPTED);

			} catch (ZipException zipEx) {
				
				logger.fatal("Error while trying to unzip the testcases file");
				logger.fatal(zipEx.getMessage());
				
				ForCodeError error = ErrorFactory.getErrorFromIndex(ErrorFactory.UNZIP_ERROR);
				builder = Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(error);

			}

		}
		return builder.build();
	}

}
