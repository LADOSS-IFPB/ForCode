package br.edu.service.forcode.services;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;

import org.apache.commons.io.FileUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jboss.resteasy.annotations.providers.multipart.MultipartForm;

import br.edu.commons.forcode.contests.ForCodeUploadFile;
import br.edu.commons.forcode.contests.Problem;
import br.edu.commons.forcode.contests.Submission;
import br.edu.commons.forcode.entities.ForCodeError;
import br.edu.commons.forcode.enumerations.FileType;
import br.edu.service.forcode.database.dao.ProblemDAO;
import br.edu.service.forcode.database.dao.SubmissionDAO;
import br.edu.service.forcode.judgeServices.JudgeService;
import br.edu.service.forcode.judgeServices.ProviderServiceFactory;
import br.edu.service.forcode.util.ErrorFactory;

@Path("upload")
public class ForCodeUploadService {
	/**
	 * Is responsible for update the submission path in the database;
	 * 
	 * @author: rerissondaniel
	 */

	private static final Logger logger = LogManager.getLogger(ForCodeUploadService.class);
	
	private static final String SUBMISSION_PATH = "/home/ForCode/Contests/";
	private static final String TESTCASE_PATH = "/home/ForCode/Problems/";
	private static final String TEMP_FOLDER = "/home/ForCode/.tmp";
	private static final int MAX_FILE_SIZE_IN_BYTES = 1000000;
	
	@POST
	@Path("/submission/{idSubmission}")
	@Consumes("multipart/form-data; charset=UTF-8")
	public Response judgeSubmissionFile(
			@PathParam("idSubmission") Integer idSubmission,
			@MultipartForm ForCodeUploadFile form) {

		ResponseBuilder builder;
		
		if(form.getFileType().getId() != FileType.SUBMISSION_FILE.getId()){
			logger.info("File for submission not accepted.");
			builder = Response.status(Response.Status.NOT_ACCEPTABLE);
			
		}else if(form.getFile().length >= MAX_FILE_SIZE_IN_BYTES){
			logger.info("Submission file is too large.");
			ForCodeError error = ErrorFactory.getErrorFromIndex(ErrorFactory.FILE_TOO_LARGE);
			builder = Response.status(Response.Status.NOT_ACCEPTABLE).entity(error);
			
		}else{
			SubmissionDAO submissionDao = new SubmissionDAO();
			Submission submission = submissionDao.getById(idSubmission);
			JudgeService judgeService = ProviderServiceFactory.createServiceClient(JudgeService.class);
	
			File submissionFile = new File(SUBMISSION_PATH
					+ submission.getUser().getIdUserContest()
					+ submission.getIdSubmission() + form.getFileName() + "." +form.getFileExtension());
			
			try{
				FileUtils.writeByteArrayToFile(submissionFile, form.getFile());
				
				submission.setFileSubmission(submissionFile);
				submission.setVerdict(judgeService.judgeSubmission(submission).getTypeValue());
				
				submissionDao.update(submission);
				
				builder = Response.status(Response.Status.ACCEPTED).entity(submission);
			}catch(IOException ioException){
					
				builder = Response.status(Response.Status.INTERNAL_SERVER_ERROR);
			}
		}
		
		return builder.build();
	}

	/**
	 * receives the zip file containing the test cases for the problem
	 * specified by idProblem.
	 * is responsible for update the problem data in database.
	 * 
	 * @author: rerissondaniel
	 */

	@POST
	@Path("testcase/{idProblem}")
	@Consumes("multipart/form-data; charset=UTF-8")
	public Response uploadTestCaseFile(
			@PathParam("idProblem") Integer idProblem,
			@MultipartForm ForCodeUploadFile form) {
		
		ResponseBuilder builder;
		
		if(form.getFileType().getId() != FileType.PROBLEM_TEST_ZIP.getId()){
			builder = Response.status(Response.Status.NOT_ACCEPTABLE);
			
		}else if(form.getFile().length >= 100 * MAX_FILE_SIZE_IN_BYTES){
			
		}else{
		
			ProblemDAO problemDao = new ProblemDAO();
			Problem problem = problemDao.getById(idProblem);
			
			ZipInputStream zipInputStream = new ZipInputStream(new ByteArrayInputStream(form.getFile()));
			ZipEntry entry = null;
			
			
			try {
				while((entry = zipInputStream.getNextEntry()) != null){
					
				}
			} catch (IOException e) {
				builder = Response.status(Response.Status.INTERNAL_SERVER_ERROR);
				e.printStackTrace();
			}
			
		}
		return null;
	}
	
}
